/**
 * Flowtype definitions for util
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.14.1
 * @flow
 */

import { ZalgoPromise } from "zalgo-promise";
import type { CancelableType } from "./types";
declare export function getFunctionName<T: (...args: Array<any>) => any>(
  fn: T
): string;
declare export function setFunctionName<T: (...args: Array<any>) => any>(
  fn: T,
  name: string
): T;
declare export function base64encode(str: string): string;
declare export function base64decode(str: string): string;
declare export function uniqueID(): string;
declare export function getGlobal(): { [key: string]: any, ... };
declare export function getObjectID(obj: { [key: string]: any, ... }): string;
declare export function getEmptyObject(): { [key: string]: void, ... };
declare type MemoizeOptions = {
  name?: string,
  time?: number,
  thisNamespace?: boolean,
  ...
};
export type Memoized<F> = {
  ...F,
  ...{
    reset: () => void,
    ...
  },
};
declare var memoize: typeof npm$namespace$memoize;

declare var npm$namespace$memoize: {|
  <F: (...args: Array<any>) => any>(
    method: F,
    options?: MemoizeOptions
  ): Memoized<F>,
  clear: typeof memoize$clear,
|};
declare var memoize$clear: () => void;
declare export function promiseIdentity<T: mixed>(
  item: ZalgoPromise<T> | T
): ZalgoPromise<T>;
declare export function memoizePromise<R>(
  method: (...args: $ReadOnlyArray<any>) => ZalgoPromise<R>
): (...args: $ReadOnlyArray<any>) => ZalgoPromise<R>;
declare type PromisifyOptions = {
  name?: string,
  ...
};
declare export function promisify<R>(
  method: (...args: $ReadOnlyArray<any>) => R,
  options?: PromisifyOptions
): (...args: $ReadOnlyArray<any>) => ZalgoPromise<R>;
declare export function inlineMemoize<R>(
  method: (...args: $ReadOnlyArray<any>) => R,
  logic: (...args: $ReadOnlyArray<any>) => R,
  args?: $ReadOnlyArray<any>
): R;
declare export function noop(...args: $ReadOnlyArray<mixed>): void;
declare export function once(
  method: (...args: Array<any>) => any
): (...args: Array<any>) => any;
declare export function hashStr(str: string): number;
declare export function strHashStr(str: string): string;
declare export function match(
  str: string,
  pattern: RegExp
): string | null | void;
declare export function awaitKey<T: mixed>(
  obj: { [key: string]: any, ... },
  key: string
): ZalgoPromise<T>;
declare export function stringifyError(err: mixed, level?: number): string;
declare export function stringifyErrorMessage(err: Error): string;
declare export function stringify(item: mixed): string;
declare export function domainMatches(
  hostname: string,
  domain: string
): boolean;
declare export function patchMethod(
  obj: { [key: string]: any, ... },
  name: string,
  handler: (...args: Array<any>) => any
): void;
declare export function extend<
  T: { [key: string]: any, ... } | ((...args: Array<any>) => any)
>(
  obj: T,
  source: { [key: string]: any, ... }
): T;
declare export function values<T>(obj: {
  [key: string]: T,
  ...
}): $ReadOnlyArray<T>;
declare export var memoizedValues: <T>(arg0: {
  [key: string]: T,
  ...
}) => $ReadOnlyArray<T>;
declare export function perc(pixels: number, percentage: number): number;
declare export function min(...args: $ReadOnlyArray<number>): number;
declare export function max(...args: $ReadOnlyArray<number>): number;
declare export function roundUp(num: number, nearest: number): number;
declare export function regexMap<T>(
  str: string,
  regexp: RegExp,
  handler: () => T
): $ReadOnlyArray<T>;
declare export function svgToBase64(svg: string): string;
declare export function objFilter<T, R>(
  obj: { [key: string]: T, ... },
  filter?: (arg0: T, arg1: string | null | void) => mixed
): { [key: string]: R, ... };
declare export function identity<T>(item: T): T;
declare export function regexTokenize(
  text: string,
  regexp: RegExp
): $ReadOnlyArray<string>;
declare export function promiseDebounce<T>(
  method: () => ZalgoPromise<T> | T,
  delay?: number
): () => ZalgoPromise<T>;
declare export function safeInterval(
  method: (...args: Array<any>) => any,
  time: number
): {
  cancel: () => void,
  ...
};
declare export function isInteger(str: string): boolean;
declare export function isFloat(str: string): boolean;
declare export function serializePrimitive(
  value: string | number | boolean
): string;
declare export function deserializePrimitive(
  value: string
): string | number | boolean;
declare export function dotify(
  obj: { [key: string]: any, ... },
  prefix?: string,
  newobj?: { [key: string]: any, ... }
): { [key: string]: string, ... };
declare export function undotify(obj: { [key: string]: string, ... }): {
  [key: string]: any,
  ...
};
export type EventEmitterType = {
  on: (
    eventName: string,
    handler: (...args: Array<any>) => any
  ) => CancelableType,
  once: (
    eventName: string,
    handler: (...args: Array<any>) => any
  ) => CancelableType,
  trigger: (
    eventName: string,
    ...args: $ReadOnlyArray<mixed>
  ) => ZalgoPromise<void>,
  triggerOnce: (
    eventName: string,
    ...args: $ReadOnlyArray<mixed>
  ) => ZalgoPromise<void>,
  reset: () => void,
  ...
};
declare export function eventEmitter(): EventEmitterType;
declare export function camelToDasherize(string: string): string;
declare export function dasherizeToCamel(string: string): string;
declare export function capitalizeFirstLetter(string: string): string;
declare export function get(
  item: { [key: string]: any, ... },
  path: string,
  def: mixed
): mixed;
declare export function safeTimeout(
  method: (...args: Array<any>) => any,
  time: number
): void;
declare export function defineLazyProp<T>(
  obj: { [key: string]: any, ... } | $ReadOnlyArray<mixed>,
  key: string | number,
  getter: () => T
): void;
declare export function arrayFrom<T>(item: Iterable<T>): $ReadOnlyArray<T>;
declare export function isObject(item: mixed): boolean;
declare export function isObjectObject(obj: mixed): boolean;
declare export function isPlainObject(obj: mixed): boolean;
declare export function replaceObject<
  T: $ReadOnlyArray<mixed> | { [key: string]: any, ... }
>(
  item: T,
  replacer: (arg0: mixed, arg1: string | number, arg2: string) => mixed,
  fullKey?: string
): T;
declare export function copyProp(
  source: { [key: string]: any, ... },
  target: { [key: string]: any, ... },
  name: string,
  def: mixed
): void;
declare type RegexResultType = {
  text: string,
  groups: $ReadOnlyArray<string>,
  start: number,
  end: number,
  length: number,
  replace: (text: string) => string,
  ...
};
declare export function regex(
  pattern: string | RegExp,
  string: string,
  start?: number
): RegexResultType | null | void;
declare export function regexAll(
  pattern: string | RegExp,
  string: string
): $ReadOnlyArray<RegexResultType>;
declare export function isDefined(value: mixed | null | void): boolean;
declare export function cycle(
  method: (...args: Array<any>) => any
): ZalgoPromise<void>;
declare export function debounce<T>(
  method: (...args: $ReadOnlyArray<mixed>) => T,
  time?: number
): (...args: $ReadOnlyArray<mixed>) => void;
declare export function isRegex(item: mixed): boolean;
declare type FunctionProxy<T: (...args: Array<any>) => any> = (method: T) => T;
declare export var weakMapMemoize: FunctionProxy<any>;
declare type FunctionPromiseProxy<
  R: mixed,
  T: (...args: $ReadOnlyArray<mixed>) => ZalgoPromise<R>
> = (arg0: T) => T;
declare export var weakMapMemoizePromise: FunctionPromiseProxy<any, any>;
declare export function getOrSet<T: mixed>(
  obj: { [key: string]: any, ... },
  key: string,
  getter: () => T
): T;
export type CleanupType = {
  set: <T: mixed>(arg0: string, arg1: T) => T,
  register: (arg0: (...args: Array<any>) => any) => void,
  all: (err?: mixed) => ZalgoPromise<void>,
  ...
};
declare export function cleanup(obj: { [key: string]: any, ... }): CleanupType;
declare export function tryCatch<T>(fn: () => T):
  | {
      result: T,
      error: void,
      ...
    }
  | {
      result: T | void,
      error: mixed,
      ...
    };
declare export function removeFromArray<X, T: Array<X>>(arr: T, item: X): void;
declare export function assertExists<T>(
  name: string,
  thing: void | null | T
): T;
declare export function unique(
  arr: $ReadOnlyArray<string>
): $ReadOnlyArray<string>;
declare export var constHas: <
  X: string | number | boolean,
  T: { [key: string]: X, ... }
>(
  constant: T,
  value: X
) => boolean;
declare export function dedupeErrors<T>(
  handler: (arg0: mixed) => T
): (arg0: mixed) => T | void;
declare export class ExtendableError mixins Error {
  constructor(message: string): this;
}
declare export {};
